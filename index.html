<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser â€“ Hill with Rolling Bot & Double Jump</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
  <style>html,body{margin:0;background:#0b0f14}</style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 960,
  height: 540,
  backgroundColor: '#0b0f14',
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 900 }, debug: false }
  },
  scene: { preload, create, update }
};
new Phaser.Game(config);

let player, bot, ground;
let cursors, aKey, dKey, wKey, spaceKey, escKey;
let canMove = true;
let dialogOpen = false;
let nearPrompt, dialogGroup;

let canDoubleJump = false;
let jumpKey;

// bot patrol settings (hill range)
let botPatrol = {
  minX: 340,  // left limit of hill patrol
  maxX: 780,  // right limit of hill patrol
  speed: 90   // roll speed
};

function preload() {
  // Player texture (green rectangle)
  const g1 = this.add.graphics();
  g1.fillStyle(0x3ad97a,1).fillRoundedRect(0,0,24,36,6);
  g1.lineStyle(2,0x1b6138,1).strokeRoundedRect(0,0,24,36,6);
  g1.generateTexture('playerTex',24,36); g1.destroy();

  // Bot texture (blue circle so it looks like a rolling ball)
  const g2 = this.add.graphics();
  g2.fillStyle(0x3aa1ff,1).fillCircle(16,16,16);
  g2.lineStyle(3,0x124a84,1).strokeCircle(16,16,16);
  g2.generateTexture('botTex',32,32); g2.destroy();

  // Ground tile (grey)
  const g3 = this.add.graphics();
  g3.fillStyle(0x4b5c6b,1).fillRect(0,0,64,24);
  g3.lineStyle(2,0x2c3640,1).strokeRect(0,0,64,24);
  g3.generateTexture('tile',64,24); g3.destroy();
}

function create() {
  const W = this.scale.width;
  const H = this.scale.height;

  // One "hill" made of stepped tiles
  ground = this.physics.add.staticGroup();
  const baseY = H - 40;
  let x = 40;

  // slope up
  for (let i = 0; i < 10; i++) {
    ground.create(x, baseY - i * 10, 'tile').refreshBody();
    x += 64;
  }
  // short flat bit at the top
  for (let i = 0; i < 5; i++) {
    ground.create(x, baseY - 9 * 10, 'tile').refreshBody();
    x += 64;
  }

  // Player at left bottom
  player = this.physics.add.sprite(80, baseY - 100, 'playerTex');
  player.setCollideWorldBounds(true);
  player.body.setSize(20,34).setOffset(2,2);
  player.setDragX(1000);

  // Rolling bot near top of hill
  bot = this.physics.add.sprite(520, baseY - 9 * 10 - 30, 'botTex');
  bot.setCollideWorldBounds(true);
  bot.setBounce(0);
  bot.body.setCircle(16);           // circular hitbox
  bot.body.setOffset(0,0);
  bot.setVelocityX(botPatrol.speed); // start rolling to the right

  // Collisions with hill
  this.physics.add.collider(player, ground);
  this.physics.add.collider(bot, ground);

  // Controls
  cursors = this.input.keyboard.createCursorKeys();
  aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
  dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
  wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
  jumpKey = wKey; // jump with W (you can change to cursors.up)

  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  escKey   = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);

  // Hint text
  nearPrompt = this.add.text(0,0,'SPACE to talk',{
    fontFamily:'Arial', fontSize:'16px', color:'#fff',
    backgroundColor:'#1a2733', padding:{left:8,right:8,top:4,bottom:4}
  }).setAlpha(0).setDepth(1000);

  // Dialog UI (hidden by default)
  dialogGroup = this.add.container(W/2, 120).setDepth(1500).setVisible(false);
  const panel = this.add.rectangle(0,0, 420, 130, 0x0f1822, 0.96)
                  .setStrokeStyle(2, 0x3aa1ff, 1).setOrigin(0.5);
  const txt1  = this.add.text(0,-26, 'ðŸ¤– Bot: What do you want?', {
                  fontFamily:'Arial', fontSize:'20px', color:'#ffffff'
                }).setOrigin(0.5);
  const txt2  = this.add.text(0,12, 'SPACE: Continue   â€¢   ESC: Cancel', {
                  fontFamily:'Arial', fontSize:'16px', color:'#b7c9d3'
                }).setOrigin(0.5);
  dialogGroup.add([panel, txt1, txt2]);

  // Open / close dialog with SPACE / ESC
  spaceKey.on('down', () => {
    if (isCloseToBot() && !dialogOpen) openDialog.call(this);
    else if (dialogOpen) closeDialog();
  });
  escKey.on('down', () => { if (dialogOpen) closeDialog(); });

  // Camera follow
  this.cameras.main.startFollow(player, true, 0.15, 0.15);
  this.cameras.main.setBounds(0,0,W,H);
}

function update() {
  const onGround = player.body.blocked.down || player.body.touching.down;

  // reset double-jump when we are on ground
  if (onGround) canDoubleJump = true;

  // Player movement (if not in dialog)
  if (canMove) {
    const speed = 220;
    if (cursors.left.isDown || aKey.isDown)      player.setVelocityX(-speed);
    else if (cursors.right.isDown || dKey.isDown)player.setVelocityX(speed);
    else                                         player.setVelocityX(0);

    // Double jump logic
    if (Phaser.Input.Keyboard.JustDown(jumpKey)) {
      if (onGround) {
        // first jump
        player.setVelocityY(-420);
        canDoubleJump = true;
      } else if (canDoubleJump) {
        // second jump in air
        player.setVelocityY(-420);
        canDoubleJump = false;
      }
    }
  } else {
    player.setVelocityX(0);
  }

  // === Bot rolling up and down the hill ===
  if (!dialogOpen) {
    const bOnGround = bot.body.blocked.down || bot.body.touching.down;

    // Flip direction at patrol edges
    if (bot.x <= botPatrol.minX && bot.body.velocity.x < 0) {
      bot.setVelocityX(botPatrol.speed);
    } else if (bot.x >= botPatrol.maxX && bot.body.velocity.x > 0) {
      bot.setVelocityX(-botPatrol.speed);
    }

    // If bot somehow slows/stops on the ground, kick it back into motion
    if (bOnGround && Math.abs(bot.body.velocity.x) < 10) {
      const dir = (bot.x < (botPatrol.minX + botPatrol.maxX)/2) ? 1 : -1;
      bot.setVelocityX(dir * botPatrol.speed);
    }

    // Visual rolling: spin based on speed
    bot.rotation += bot.body.velocity.x * 0.0008;
  } else {
    bot.setVelocityX(0); // stop rolling when in dialog
  }

  // Hint: show when close to bot and not in dialog
  if (!dialogOpen && isCloseToBot()) {
    nearPrompt.setPosition(bot.x, bot.y - 48).setAlpha(0.95);
  } else {
    nearPrompt.setAlpha(0);
  }
}

/* ------------ Helpers ------------ */

function isCloseToBot() {
  const dx = Math.abs(player.x - bot.x);
  const dy = Math.abs(player.y - bot.y);
  return dx < 40 && dy < 60;
}

function openDialog() {
  canMove = false;
  dialogOpen = true;
  dialogGroup.setVisible(true);
  this.tweens.add({
    targets: dialogGroup,
    scale: { from: 0.9, to: 1 },
    alpha: { from: 0, to: 1 },
    duration: 120
  });
}

function closeDialog() {
  dialogOpen = false;
  dialogGroup.setVisible(false);
  canMove = true;
}
</script>
</body>
</html>
