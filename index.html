<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser – 14×14 Maze (Red Player, Single Entry/Exit)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>html,body{margin:0;background:#101015}</style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 900,
  height: 560,
  backgroundColor: '#101015',
  scene: { preload(){}, create, update }
};
new Phaser.Game(config);

// ===== SETTINGS =====
const CELLSX = 14, CELLSY = 14;   // path cells (not counting walls)
const TILE   = 28;                 // pixels per grid tile

// ===== STATE =====
let S, GFX, W, H;
let grid, startGate, endGate, dims={gw:0,gh:0}, offset={x:0,y:0};
let player, playerGrid={x:0,y:0}, moving=false;
let keys, winText;

function create(){
  S = this; W = S.scale.width; H = S.scale.height;
  GFX = S.add.graphics();

  S.add.text(16, 12, 'WASD / Arrows to move • R to randomise', {
    fontFamily:'Arial Black', fontSize:'18px', color:'#e5d6a7'
  });

  makeButton(S, W-120, 22, 110, 36, 'Randomise', rebuild);
  S.input.keyboard.on('keydown-R', rebuild);

  keys = S.input.keyboard.addKeys({
    W:'W',A:'A',S:'S',D:'D',
    UP:'UP',LEFT:'LEFT',DOWN:'DOWN',RIGHT:'RIGHT'
  });

  // RED player texture (very visible)
  const g = S.add.graphics();
  g.fillStyle(0xff2b2b, 1).fillRoundedRect(0,0,TILE-8,TILE-8,4);
  g.lineStyle(2, 0xffffff, 0.8).strokeRoundedRect(0,0,TILE-8,TILE-8,4);
  g.generateTexture('playerRed', TILE-8, TILE-8);
  g.destroy();

  winText = S.add.text(W/2, H-28, 'You escaped! Press R for a new maze.', {
    fontFamily:'Arial Black', fontSize:'20px', color:'#24b2ff'
  }).setOrigin(0.5).setAlpha(0);

  rebuild();
}

function update(){
  if (moving) return;
  let dx=0, dy=0;
  if (Phaser.Input.Keyboard.JustDown(keys.W) || Phaser.Input.Keyboard.JustDown(keys.UP)) dy=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.S) || Phaser.Input.Keyboard.JustDown(keys.DOWN)) dy= 1;
  else if (Phaser.Input.Keyboard.JustDown(keys.A) || Phaser.Input.Keyboard.JustDown(keys.LEFT)) dx=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.D) || Phaser.Input.Keyboard.JustDown(keys.RIGHT)) dx= 1;
  if (dx||dy) tryMove(dx,dy);
}

function tryMove(dx,dy){
  const nx = playerGrid.x + dx;
  const ny = playerGrid.y + dy;
  if (ny>=0 && ny<dims.gh && nx>=0 && nx<dims.gw && grid[ny][nx]===0){
    moving = true;
    playerGrid.x = nx; playerGrid.y = ny;
    const p = gridToPx(nx, ny);
    S.tweens.add({
      targets: player, x: p.x, y: p.y, duration: 110, ease: 'Sine.easeOut',
      onComplete: ()=>{
        moving=false;
        // Win when you step onto the cell just inside the TOP gate (row 1)
        if (playerGrid.y === 1 && playerGrid.x === startGate.x) {
          S.tweens.add({ targets: winText, alpha: 1, duration: 200 });
        }
      }
    });
  }
}

function rebuild(){
  const gen = generateMaze(CELLSX, CELLSY);
  grid = gen.grid; startGate = gen.start; endGate = gen.end;
  dims.gw = grid[0].length; dims.gh = grid.length;

  // center drawing
  offset.x = Math.floor((W - dims.gw*TILE)/2);
  offset.y = Math.floor((H - dims.gh*TILE)/2);

  drawMaze(GFX, grid, startGate, endGate);

  // Spawn player at the cell just INSIDE the bottom gate (row GH-2)
  const spawn = { x: endGate.x, y: dims.gh - 2 };
  playerGrid = spawn;
  const p = gridToPx(spawn.x, spawn.y);
  if (!player) player = S.add.image(p.x, p.y, 'playerRed').setDepth(10);
  else player.setPosition(p.x, p.y);

  winText.setAlpha(0);
}

/* ===== Maze generation (recursive backtracker) ===== */
function generateMaze(cols, rows){
  const GW = 2*cols + 1, GH = 2*rows + 1;               // full grid (walls+paths)
  const grid = Array.from({length:GH},()=>Array(GW).fill(1)); // 1=wall, 0=path

  // carve
  const visited = Array.from({length:rows},()=>Array(cols).fill(false));
  const startCell = { x: Phaser.Math.Between(0, cols-1), y: Phaser.Math.Between(0, rows-1) };
  const stack=[startCell];
  visited[startCell.y][startCell.x]=true;
  grid[startCell.y*2+1][startCell.x*2+1]=0;

  while(stack.length){
    const cur = stack[stack.length-1];
    const nbs=[];
    if(cur.y>0        && !visited[cur.y-1][cur.x]) nbs.push({x:cur.x, y:cur.y-1});
    if(cur.y<rows-1   && !visited[cur.y+1][cur.x]) nbs.push({x:cur.x, y:cur.y+1});
    if(cur.x>0        && !visited[cur.y][cur.x-1]) nbs.push({x:cur.x-1, y:cur.y});
    if(cur.x<cols-1   && !visited[cur.y][cur.x+1]) nbs.push({x:cur.x+1, y:cur.y});

    if(nbs.length){
      const nb = Phaser.Utils.Array.GetRandom(nbs);
      const gx=cur.x*2+1, gy=cur.y*2+1;
      const nx=nb.x*2+1,  ny=nb.y*2+1;
      grid[(gy+ny)/2][(gx+nx)/2]=0; // knock wall
      grid[ny][nx]=0;               // carve
      visited[nb.y][nb.x]=true;
      stack.push(nb);
    } else stack.pop();
  }

  // Choose ONE exit at TOP (row 0) and ONE entry at BOTTOM (row GH-1)
  const topChoices=[], botChoices=[];
  for(let x=1;x<GW-1;x+=2){
    if(grid[1][x]===0)    topChoices.push(x);
    if(grid[GH-2][x]===0) botChoices.push(x);
  }
  const topX = Phaser.Utils.Array.GetRandom(topChoices) ?? 1;
  const botX = Phaser.Utils.Array.GetRandom(botChoices) ?? (GW-2);

  // Seal all edge cells, then open exactly one tile at top & bottom
  for(let x=0;x<GW;x++){ grid[0][x]=1; grid[GH-1][x]=1; }
  for(let y=0;y<GH;y++){ grid[y][0]=1; grid[y][GW-1]=1; } // left/right walls too
  grid[0][topX]=0;         // top exit
  grid[GH-1][botX]=0;      // bottom entry

  return { grid, start:{x:topX,y:0}, end:{x:botX,y:GH-1} };
}

/* ===== Rendering ===== */
function drawMaze(g, grid, start, end){
  g.clear();
  const GW=grid[0].length, GH=grid.length, offX=offset.x, offY=offset.y;

  // Draw walls first (so border is obvious)
  g.fillStyle(0x1f2330, 1);  // dark walls
  for(let y=0;y<GH;y++){
    for(let x=0;x<GW;x++){
      if(grid[y][x]===1){
        g.fillRect(offX+x*TILE, offY+y*TILE, TILE, TILE);
      }
    }
  }

  // Draw corridors (brown) on top of walls for crisp paths
  g.fillStyle(0x7a5a34, 1);
  for(let y=0;y<GH;y++){
    for(let x=0;x<GW;x++){
      if(grid[y][x]===0){
        g.fillRect(offX+x*TILE, offY+y*TILE, TILE, TILE);
      }
    }
  }

  // Gates (blue) – clearly visible
  g.fillStyle(0x24b2ff, 1);
  g.fillRect(offX+start.x*TILE, offY+start.y*TILE, TILE, TILE);        // top exit
  g.fillRect(offX+end.x*TILE,   offY+end.y*TILE,   TILE, TILE);        // bottom entry

  // Bold border frame around whole maze
  g.lineStyle(4, 0xf2d16d, 1);
  g.strokeRect(offX, offY, GW*TILE, GH*TILE);
}

function gridToPx(gx,gy){
  return { x: offset.x + gx*TILE + TILE/2, y: offset.y + gy*TILE + TILE/2 };
}

/* ===== UI helpers ===== */
function makeButton(scene,x,y,w,h,label,onClick){
  const g = scene.add.graphics({x:x-w/2, y:y-h/2});
  drawBtn(g,w,h,false);
  scene.add.text(x,y,label,{fontFamily:'Arial',fontSize:'16px',color:'#fff'}).setOrigin(0.5);
  scene.add.zone(x,y,w,h).setInteractive({useHandCursor:true})
    .on('pointerover',()=>drawBtn(g,w,h,true))
    .on('pointerout', ()=>drawBtn(g,w,h,false))
    .on('pointerdown',()=>onClick&&onClick());
}
function drawBtn(g,w,h,hover){
  g.clear();
  g.fillStyle(hover?0x009a70:0x006e51,1);
  g.fillRoundedRect(0,0,w,h,8);
  g.lineStyle(2,0xe6d971,1);
  g.strokeRoundedRect(0,0,w,h,8);
}
</script>
</body>
</html>
