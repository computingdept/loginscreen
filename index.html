<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser – 14×14 Maze (WASD + Randomise)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
  <style>html,body{margin:0;background:#1c1208}</style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 900,
  height: 560,
  backgroundColor: '#1c1208',
  scene: { preload(){}, create, update }
};
new Phaser.Game(config);

// --- Maze settings ---
const CELLSX = 14;  // columns of path cells
const CELLSY = 14;  // rows of path cells
const TILE   = 28;  // pixel size per grid tile (fits nicely in 900×560)

let scene, gfx, W, H;
let grid, start, end, dims={gw:0,gh:0}, offset={x:0,y:0};
let player, playerGrid={x:0,y:0}, moving=false;
let keys, winText;

function create(){
  scene = this; W = this.scale.width; H = this.scale.height;
  gfx = this.add.graphics();

  // Title + hint
  this.add.text(16, 12, '14×14 Maze — WASD/Arrows to move • R to randomise', {
    fontFamily:'Arial Black', fontSize:'18px', color:'#e5d6a7'
  });

  // Randomise button
  makeButton(this, W - 120, 22, 110, 36, 'Randomise', rebuild);
  this.input.keyboard.on('keydown-R', rebuild);

  // Input (we'll poll with JustDown)
  keys = this.input.keyboard.addKeys({
    W:'W',A:'A',S:'S',D:'D', UP:'UP',LEFT:'LEFT',DOWN:'DOWN',RIGHT:'RIGHT'
  });

  // Player texture (orange square)
  const g = this.add.graphics();
  g.fillStyle(0xff8a3d, 1).fillRoundedRect(0,0,TILE-10,TILE-10,4);
  g.generateTexture('playerBox', TILE-10, TILE-10);
  g.destroy();

  // Win text (hidden until you reach the top gate)
  winText = this.add.text(W/2, H-28, 'You escaped! Press R for a new maze.', {
    fontFamily:'Arial Black', fontSize:'20px', color:'#24b2ff'
  }).setOrigin(0.5).setAlpha(0);

  rebuild();
}

function update(){
  if (moving) return;
  let dx=0, dy=0;
  if (Phaser.Input.Keyboard.JustDown(keys.W) || Phaser.Input.Keyboard.JustDown(keys.UP))    dy=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.S) || Phaser.Input.Keyboard.JustDown(keys.DOWN)) dy= 1;
  else if (Phaser.Input.Keyboard.JustDown(keys.A) || Phaser.Input.Keyboard.JustDown(keys.LEFT)) dx=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.D) || Phaser.Input.Keyboard.JustDown(keys.RIGHT))dx= 1;

  if (dx||dy) tryMove(dx,dy);
}

function tryMove(dx,dy){
  const nx = playerGrid.x + dx;
  const ny = playerGrid.y + dy;
  if (ny>=0 && ny<dims.gh && nx>=0 && nx<dims.gw && grid[ny][nx]===0){
    moving = true;
    playerGrid.x = nx; playerGrid.y = ny;
    const p = gridToPx(nx, ny);
    scene.tweens.add({
      targets: player, x: p.x, y: p.y, duration: 110, ease: 'Sine.easeOut',
      onComplete: ()=> {
        moving=false;
        // Win when you step onto the cell just inside the top gate (row 1)
        if (playerGrid.y === 1 && playerGrid.x === start.x) {
          scene.tweens.add({ targets: winText, alpha: 1, duration: 200 });
        }
      }
    });
  }
}

function rebuild(){
  // Fresh maze
  const gen = generateMaze(CELLSX, CELLSY);
  grid=gen.grid; start=gen.start; end=gen.end;
  dims.gw = grid[0].length; dims.gh = grid.length;

  // Center on canvas
  const drawW = dims.gw*TILE, drawH = dims.gh*TILE;
  offset.x = Math.floor((W - drawW)/2);
  offset.y = Math.floor((H - drawH)/2);

  drawMaze(gfx, grid, start, end);

  // Spawn player just inside the bottom gate
  const spawn = { x: end.x, y: end.y===dims.gh-1 ? end.y-1 : end.y+1 };
  playerGrid = spawn;
  const p = gridToPx(spawn.x, spawn.y);
  if (!player) player = scene.add.image(p.x, p.y, 'playerBox').setDepth(5);
  else player.setPosition(p.x, p.y);

  winText.setAlpha(0);
}

/* ---------- Maze generation: recursive backtracker ---------- */
function generateMaze(cols, rows){
  const GW = 2*cols + 1;    // full grid width (paths + walls)
  const GH = 2*rows + 1;    // full grid height
  const grid = Array.from({length:GH},()=>Array(GW).fill(1)); // 1=wall, 0=path

  const visited = Array.from({length:rows},()=>Array(cols).fill(false));
  const stack=[{x:0,y:rows-1}]; // start carving near bottom-left for variety
  visited[rows-1][0]=true;
  grid[rows*2-1][1]=0; // map to full grid coords

  while(stack.length){
    const cur = stack[stack.length-1];
    const nbs=[];
    if(cur.y>0 && !visited[cur.y-1][cur.x]) nbs.push({x:cur.x,y:cur.y-1});
    if(cur.y<rows-1 && !visited[cur.y+1][cur.x]) nbs.push({x:cur.x,y:cur.y+1});
    if(cur.x>0 && !visited[cur.y][cur.x-1]) nbs.push({x:cur.x-1,y:cur.y});
    if(cur.x<cols-1 && !visited[cur.y][cur.x+1]) nbs.push({x:cur.x+1,y:cur.y});

    if(nbs.length){
      const nb = Phaser.Utils.Array.GetRandom(nbs);
      const gx = cur.x*2+1, gy = cur.y*2+1;
      const nx = nb.x*2+1,  ny = nb.y*2+1;
      grid[(gy+ny)/2][(gx+nx)/2]=0; // break wall
      grid[ny][nx]=0;               // carve
      visited[nb.y][nb.x]=true;
      stack.push(nb);
    } else stack.pop();
  }

  // Open top exit & bottom entry on existing corridors
  const topCols=[], botCols=[];
  for(let x=1;x<GW-1;x+=2){ if(grid[1][x]===0) topCols.push(x); if(grid[GH-2][x]===0) botCols.push(x); }
  const topX = Phaser.Utils.Array.GetRandom(topCols) ?? 1;
  const botX = Phaser.Utils.Array.GetRandom(botCols) ?? (GW-2);
  grid[0][topX]=0;          // exit (top)
  grid[GH-1][botX]=0;       // entry (bottom)

  return { grid, start:{x:topX,y:0}, end:{x:botX,y:GH-1} };
}

/* ---------------- Rendering ---------------- */
function drawMaze(g, grid, start, end){
  g.clear();
  const GW=grid[0].length, GH=grid.length, offX=offset.x, offY=offset.y;

  // Corridors (brown)
  g.fillStyle(0x7a5a34,1);
  for(let y=0;y<GH;y++)
    for(let x=0;x<GW;x++)
      if(grid[y][x]===0) g.fillRect(offX+x*TILE, offY+y*TILE, TILE, TILE);

  // Gates (blue)
  g.fillStyle(0x24b2ff,1);
  g.fillRect(offX+start.x*TILE, offY+start.y*TILE, TILE, TILE);
  g.fillRect(offX+end.x*TILE,   offY+end.y*TILE,   TILE, TILE);

  // Border
  g.lineStyle(2,0x3a2b1a,1);
  g.strokeRect(offX, offY, GW*TILE, GH*TILE);
}

function gridToPx(gx,gy){ return { x: offset.x + gx*TILE + TILE/2, y: offset.y + gy*TILE + TILE/2 }; }

/* ---------------- UI helpers ---------------- */
function makeButton(scene, x, y, w, h, label, onClick){
  const g = scene.add.graphics({x:x-w/2, y:y-h/2});
  drawBtn(g,w,h,false);
  scene.add.text(x,y,label,{fontFamily:'Arial',fontSize:'16px',color:'#fff'}).setOrigin(0.5);
  scene.add.zone(x,y,w,h).setInteractive({useHandCursor:true})
    .on('pointerover',()=>drawBtn(g,w,h,true))
    .on('pointerout', ()=>drawBtn(g,w,h,false))
    .on('pointerdown',()=>onClick&&onClick());
}
function drawBtn(g,w,h,hover){
  g.clear();
  g.fillStyle(hover?0x009a70:0x006e51,1);
  g.fillRoundedRect(0,0,w,h,8);
  g.lineStyle(2,0xe6d971,1);
  g.strokeRoundedRect(0,0,w,h,8);
}
</script>
</body>
</html>
